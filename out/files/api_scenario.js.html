<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>api/scenario.js</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="" src="../assets/css/logo.png" style="max-height: 65%;" title="">
            
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b></b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/api.Approach", "classes/api.Auth", "classes/api.core", "classes/api.Environment", "classes/api.log", "classes/api.Query", "classes/api.QueryDOc", "classes/api.Table"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <h3>APIs</h3>
	        <div id="sidebar">
	            <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                <li><a href="#modules" data-toggle="tab">Modules</a></li>
	            </ul>
	    
	            <div id="api-tabview-filter">
	                <input type="search" placeholder="Type to filter APIs">
	            </div>
	    
	            <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                <div class="tab-pane active" id="classes">
	                    <ul id="api-classes" class="nav nav-list">
	                            <li><a href="../classes/api.Approach.html">api.Approach</a></li>
	                            <li><a href="../classes/api.Auth.html">api.Auth</a></li>
	                            <li><a href="../classes/api.core.html">api.core</a></li>
	                            <li><a href="../classes/api.Environment.html">api.Environment</a></li>
	                            <li><a href="../classes/api.log.html">api.log</a></li>
	                            <li><a href="../classes/api.Query.html">api.Query</a></li>
	                            <li><a href="../classes/api.QueryDOc.html">api.QueryDOc</a></li>
	                            <li><a href="../classes/api.Table.html">api.Table</a></li>
	                    </ul>
	                </div>
	    
	                <div class="tab-pane" id="modules">
	                    <ul id="api-modules" class="nav nav-list">
	                    </ul>
	                </div>
	            </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>api/scenario.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
var moment = require(&#x27;moment&#x27;);
var Core = require(&#x27;./core&#x27;);
var Message = require(&#x27;../config/message.json&#x27;);
var scenariodoc = require(&quot;./scenariodoc&quot;);

/** テーブル名 */
var tableName = &#x27;M_SCENARIO&#x27;;
/** PK */
var pk = &#x27;scenario_id&#x27;;
/** SEQ */
var seqName = &#x27;seq_scenario&#x27;;

/** 機能名 */
//var functionName = &#x27;シナリオ管理&#x27;;

var scenario = function scenario()
{
    Core.call(this, tableName, pk, seqName);
    moment.locale(&#x27;ja&#x27;, {
        weekdays: [&quot;日曜日&quot;,&quot;月曜日&quot;,&quot;火曜日&quot;,&quot;水曜日&quot;,&quot;木曜日&quot;,&quot;金曜日&quot;,&quot;土曜日&quot;],
        weekdaysShort: [&quot;日&quot;,&quot;月&quot;,&quot;火&quot;,&quot;水&quot;,&quot;木&quot;,&quot;金&quot;,&quot;土&quot;],
        weekdaysMin:[&quot;sun&quot;, &quot;mon&quot;, &quot;tue&quot;, &quot;wed&quot;, &quot;thu&quot;, &quot;fri&quot;, &quot;sat&quot;],
    });
};

//coreModelを継承する
var util = require(&#x27;util&#x27;);
util.inherits(scenario, Core);

var model = new scenario();

/**
 * PKからデータを取得する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.getById = function(req, res)
{
    model.getById(req.params.id, function(err, data)
    {
        if (err.length &gt; 0)
        {
            console.log(err);
            res.status(510).send(&#x27;data not found&#x27;);
            res.json({data: []});
        }
        else
        {
            model.insertLog(req.session.userId, 6, Message.COMMON.I_004, data[0].scenario_name);
            res.json({data: data});
        }
    });
};

/**
 * delete_flagのたっていないシナリオをすべて取得する
 * 並び順はPKの昇順
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.getAll = function(req, res)
{
    var col = &quot;T1.scenario_id, FORMAT(T1.update_date, &#x27;yyyy/MM/dd&#x27;) AS update_date, T1.scenario_name, &quot; +
                &quot;CASE T1.approach WHEN 1 THEN N&#x27;対象&#x27; WHEN 0 THEN N&#x27;対象外&#x27; ELSE N&#x27;未設定&#x27; END AS approach, &quot; +
                &quot;CASE T1.status WHEN 1 THEN N&#x27;有効&#x27; WHEN 0 THEN N&#x27;無効&#x27; ELSE N&#x27;未設定&#x27; END AS status, T3.tag_name&quot;;
    var table = tableName + &quot; T1 LEFT JOIN T_SCENARIO_TAG T2 ON T1.scenario_id = T2.scenario_id AND T2.delete_flag = 0 LEFT JOIN T_TAG T3 ON T2.tag_id = T3.tag_id AND T3.delete_flag = 0&quot;;
    var where = &quot;T1.delete_flag = 0 AND T1.scenario_type = @scenario_type&quot;;
    var order = &quot;T1.scenario_id&quot;;
    var qObj = model.getQueryObject(col, table, where, &#x27;&#x27;, order);
    
    var functionName = &#x27;&#x27;;
    var scenarioType = &#x27;&#x27;; 
    if (&#x27;trigger&#x27; == req.params.type) 
    {
        functionName = &#x27;トリガーシナリオ管理&#x27;;
        scenarioType = 2;
    }
    else
    {
        functionName = &#x27;スケジュールシナリオ管理&#x27;; 
        scenarioType = 1;
    }
    qObj.request.input(&#x27;scenario_type&#x27;, model.db.SmallInt, scenarioType);

    model.select(qObj, qObj.request, function(err, data)
    {
        if (err.length &gt; 0)
        {
            model.insertLog(req.session.userId, 6, Message.COMMON.E_004, functionName);
            console.log(err);
            return res.status(510).send(&#x27;シナリオデータの取得に失敗しました。&#x27;);
        }
        
        console.log(data);
        var num = data.length;
        var last = num - 1;
        var tagList = [];
        var newData = [];
        if (0 &lt; num)
        {
            var defore = data[0].scenario_id;
            for (var index = 0; index &lt; num; index++)
            {
                if (defore === data[index].scenario_id)
                {
                    tagList.push(data[index].tag_name);
                }
                else
                {
                    data[index-1].searchTag = tagList.join(&quot; &quot;);
                    newData.push(data[index-1]);
                    tagList = [];
                    tagList.push(data[index].tag_name);
                }
                if (last === index)
                {
                    data[index].searchTag = tagList.join(&quot; &quot;);
                    newData.push(data[index]);
                }
                
                defore = data[index].scenario_id;
            }
            
            //データが1件しかない、またはすべて同じデータだった場合
            if (0 === newData.length)
            {
                data[0].searchTag = tagList.join(&quot; &quot;);
                newData.push(data[0]);
                console.log(newData);
            }
        }
            
        model.insertLog(req.session.userId, 6, Message.COMMON.I_004, functionName);
        res.json({data: newData});
    });
};

/**
 * アプローチ対象のシナリオを取得する
 * 並び順はpriorityとscenario_idの昇順
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.getValid = function(req, res)
{
    var col = &quot;scenario_id, scenario_name, status, priority, valid_flag,&quot; +
                &quot;CASE scenario_type WHEN 1 THEN &#x27;schedule&#x27; WHEN 2 THEN &#x27;trigger&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type_key, &quot; +
                &quot;CASE scenario_type WHEN 1 THEN N&#x27;スケジュール&#x27; WHEN 2 THEN N&#x27;トリガー&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type&quot;;

    var where = &quot;delete_flag = 0 AND approach = 1&quot;;
    var order = &quot;priority, scenario_id&quot;;
    var qObj = model.getQueryObject(col, tableName, where, &#x27;&#x27;, order);
    
    model.select(qObj, qObj.request, function(err, data)
    {
        if (err.length &gt; 0)
        {
            console.log(err);
            res.status(510).send(&#x27;object not found&#x27;);
        }
        res.json({data: data});
    });
};

/**
 * アプローチ対象のシナリオを取得する
 * 並び順はpriorityとscenario_idの昇順
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.getScenarioCount = function(req, res)
{
    model.async.parallel(
    {
        //セグメント情報
        env: function(callback)
        {
            var env = require(&quot;./environment&quot;);
            env.get(callback);
        },
        //count
        count: function(callback)
        {
            var col = &quot;scenario_type, count(1) as regist_num, &quot;+
                &quot;CASE scenario_type WHEN 1 THEN &#x27;schedule&#x27; WHEN 2 THEN &#x27;trigger&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type_key, &quot; +
                &quot;CASE scenario_type WHEN 1 THEN N&#x27;スケジュール型シナリオ&#x27; WHEN 2 THEN N&#x27;トリガー型シナリオ&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type_name&quot;;
            var where = &quot;delete_flag = 0&quot;;
            var grop = &quot;scenario_type&quot;;
            var qObj = model.getQueryObject(col, tableName, where, grop, &#x27;&#x27;);
            
            model.select(qObj, qObj.request, callback);
        },
    },
    function complete(err, items)
    {
        var list = [];
        var envInfo = items.env[0];
        if (0 === items.count.length)
        {
            list.push({scenario_type_key: &#x27;schedule&#x27;, scenario_type_name:&#x27;スケジュール型シナリオ&#x27;, regist_num: 0, regist_max: envInfo.schedule_scenario_max});
            list.push({scenario_type_key: &#x27;trigger&#x27;, scenario_type_name:&#x27;トリガー型シナリオ&#x27;, regist_num: 0, regist_max: envInfo.trigger_scenario_max});
        }
        else if (1 === items.count.length)
        {
            var isSchedule = (1 === items.count[0].scenario_type) ? true : false;
            if (isSchedule)
            {
                items.count[0].regist_max = envInfo.schedule_scenario_max;
                list.push(items.count[0]);
                list.push({scenario_type_key: &#x27;trigger&#x27;, scenario_type_name:&#x27;トリガー型シナリオ&#x27;, regist_num: 0, regist_max: envInfo.trigger_scenario_max});
            }
            else
            {
                list.push({scenario_type_key: &#x27;schedule&#x27;, scenario_type_name:&#x27;スケジュール型シナリオ&#x27;, regist_num: 0, regist_max: envInfo.schedule_scenario_max});
                items.count[0].regist_max = envInfo.trigger_scenario_max;
                list.push(items.count[0]);
            }
        }
        else
        {
            var num = items.count.length;
            for(var index = 0; index &lt; num; index++)
            {
                if (1 === items.count[index].scenario_type)
                {
                    items.count[index].regist_max = envInfo.schedule_scenario_max;
                }
                else if (2 === items.count[index].scenario_type)
                {
                    items.count[index].regist_max = envInfo.trigger_scenario_max;
                }
            }
            list = items.count;
        }
        
        res.json({data: list});
    });
};

/**
 * 実行予定のシナリオを取得する
 * 並び順はpriorityとscenario_idの昇順
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.getExecutePlanScenario = function(req, res)
{
    var col = &quot;T1.scenario_id, T1.scenario_name, T1.valid_flag, FORMAT(T1.last_execute_date, &#x27;yyyy/MM/dd&#x27;) AS last_execute_date, T1.execute_target_num, &quot;+
        &quot;CASE T1.scenario_type WHEN 1 THEN N&#x27;スケジュール&#x27; WHEN 2 THEN N&#x27;トリガー&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type, &quot;+
        &quot;CASE T1.scenario_type WHEN 1 THEN &#x27;schedule&#x27; WHEN 2 THEN &#x27;trigger&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type_key&quot;;
    
    var table = tableName + &quot; T1 LEFT JOIN M_SCHEDULE_SCENARIO T2 ON T1.scenario_id = T2.scenario_id &quot;;
    var where = &quot;T1.delete_flag = 0 AND T1.approach = 1 AND T1.status = 1&quot;;

    where += &quot; AND ( T2.expiration_start_date is null OR (T2.expiration_start_date is not null AND expiration_end_date &gt;= @now) OR T2.expiration_start_date = @now AND T2.expiration_end_date is null)&quot;;
    
    var order = &quot;T1.priority, T1.scenario_id&quot;;
    var qObj =  model.getQueryObject(col, table, where, &#x27;&#x27;, order);
    
    var now = moment().format(&quot;YYYY/MM/DD&quot;) + &quot; 00:00:00&quot;;

    qObj.request.input(&#x27;now&#x27;, model.db.NVarChar, now);

    model.select(qObj, qObj.request, function(err, data)
    {
        if (err.length &gt; 0)
        {
            console.log(&#x27;get execute plan scenario faild&#x27;);
            console.log(err);
            res.status(510).send(&#x27;シナリオ情報の取得に失敗しました&#x27;);
        }
        
        res.json({data: data});
    });
};

/**
 * 実行予定のシナリオをカレンダー表示用に整形した結果を取得する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.getExecutePlanScenarioToCalendar = function(req, res)
{
    var col = &quot;T1.scenario_id, T1.scenario_name, T2.scenario_action_document_id, T2.expiration_start_date, T2.expiration_end_date, &quot;+
        &quot;T1.scenario_type AS scenario_type_value, &quot; +
        &quot;CASE T1.scenario_type WHEN 1 THEN N&#x27;スケジュール&#x27; WHEN 2 THEN N&#x27;トリガー&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type, &quot;+
        &quot;CASE T1.scenario_type WHEN 1 THEN &#x27;schedule&#x27; WHEN 2 THEN &#x27;trigger&#x27; ELSE N&#x27;未設定&#x27; END AS scenario_type_key&quot;;
    
    var table = tableName + &quot; T1 LEFT JOIN M_SCHEDULE_SCENARIO T2 ON T1.scenario_id = T2.scenario_id &quot;;
    var where = &quot;T1.delete_flag = 0 AND T1.approach = 1 AND T1.status = 1 AND &quot;;
    //トリガー型を取得する条件
    where += &quot;( T2.expiration_start_date is null &quot;;
    //スケジュール型：日付指定を取得する条件
    where += &quot;OR (T2.expiration_start_date BETWEEN @start AND @end AND T2.expiration_end_date is null)&quot;;
    //スケジュール型：期間指定を取得する条件
    where += &quot;OR (T2.expiration_start_date is not null AND ( T2.expiration_end_date BETWEEN @start AND @end OR T2.expiration_end_date &gt;=  @end) ) )&quot;;
    
    var order = &quot;T1.priority, T1.scenario_id&quot;;
    var qObj =  model.getQueryObject(col, table, where, &#x27;&#x27;, order);
    
    var period = 0;
    var start =&#x27;&#x27;;
    var end =&#x27;&#x27;;
    var isCalendar = req.params.hasOwnProperty(&quot;year&quot;) &amp;&amp; req.params.hasOwnProperty(&quot;month&quot;);
    
    if (req.params.hasOwnProperty(&quot;day&quot;))
    {
        start = moment(req.params.day).format(&quot;YYYY/MM/DD&quot;) + &quot; 00:00:00&quot;;
        end = moment(req.params.day).format(&quot;YYYY/MM/DD&quot;) + &quot; 23:59:59&quot;; 
        period = 1;
    }
    else if (isCalendar)
    {
        var yearMonth = req.params.year + &#x27;/&#x27; + req.params.month;
        period = moment(yearMonth).daysInMonth();
        start = moment(yearMonth+&quot;/01&quot;).format(&quot;YYYY/MM/DD&quot;) + &quot; 00:00:00&quot;;
        end = moment(yearMonth+&quot;/&quot;+period).format(&quot;YYYY/MM/DD&quot;) + &quot; 23:59:59&quot;; 
    }
    else
    {
        //初期表示の場合
        period = 5;
        start = moment().format(&quot;YYYY/MM/DD&quot;) + &quot; 00:00:00&quot;;
        end = moment().add(period, &#x27;day&#x27;).format(&quot;YYYY/MM/DD&quot;) + &quot; 00:00:00&quot; ;
    }
    console.log(start);
    console.log(end);
    var calendar = {};
    for (var i = 0; i &lt; period; i++)
    {
        var prop = moment(start).add(i, &#x27;day&#x27;).format(&quot;YYYY/MM/DD (ddd)&quot;);
        calendar[prop] = [];
    }

    qObj.request.input(&#x27;start&#x27;, model.db.NVarChar, start);
    qObj.request.input(&#x27;end&#x27;, model.db.NVarChar, end);

    model.select(qObj, qObj.request, function(err, data)
    {
        if (err.length &gt; 0)
        {
            console.log(&#x27;get execute plan scenario faild&#x27;);
            console.log(err);
            res.status(510).send(&#x27;シナリオ情報の取得に失敗しました&#x27;);
        }
        
        console.log(data);

        //スケジュールの期間指定はdocumentDBにデータが入っているため
        //データを取得する必要がある
        var dataNum = data.length;
        var docIdList = [];

        for (var index = 0; index &lt; dataNum; index++)
        {
            var target = data[index];
            //スケジュール型期間指定の場合
            if (null !== target.scenario_action_document_id &amp;&amp; 1 === target.scenario_type_value)
            {
                docIdList.push(target.scenario_action_document_id);
            }
        }
        
        model.async.waterfall(
        [
            function(callback)
            {
                console.log(docIdList);
                if (0 &lt; docIdList.length)
                {
                    console.log(&quot;scenariodoc.getItemByIdsForWeb&quot;);
                    scenariodoc.getItemByIdsForWeb(docIdList, [&quot;*&quot;], function(err, docs)
                    {
                        callback(err, docs);
                    });
                }
                else
                {
                    callback(null, null);
                }
            },
            function(docs, callback)
            {
                console.log(&quot;calendar crate&quot;);
                console.log(docs);
                
                var docsObject = (null === docs) ? {} : createDocsObject(docs);

                for (var index = 0; index &lt; dataNum; index++)
                {
                    var target = data[index];
                    console.log(target);
                    Object.keys(calendar).forEach(function(key)
                    {
                        var isAdd = false;
                        if (2 === target.scenario_type_value)
                        {
                            isAdd = true;
                            target.scenario_type_detail = 1;
                        }
                        else if (null === target.scenario_action_document_id &amp;&amp; 1 === target.scenario_type_value)
                        {
                            //スケジュール型 日付指定の場合
                            var day = moment(target.expiration_start_date).format(&quot;YYYY-MM-DD&quot;);
                            isAdd = (moment(key).format(&quot;YYYY-MM-DD&quot;) === day);
                            target.scenario_type_detail = 2;
                        }
                        else if (null !== target.scenario_action_document_id &amp;&amp; 1 === target.scenario_type_value)
                        {
                            //スケジュール型 期間指定の場合
                            var doc = docsObject[target.scenario_action_document_id];
                            //期間内であるかの判定
                            var keyDay = moment(key).format(&quot;YYYY-MM-DD&quot;);
                            var isPeriod = (moment(keyDay).isAfter(moment(target.expiration_start_date))
                                &amp;&amp; moment(moment(target.expiration_end_date)).isAfter(keyDay) );

                            //以下の条件に合わないものは不正データのため破棄
                            if (2 === doc.interval)
                            {
                                var minDay = model.momoent(key).format(&quot;dd&quot;);
                                isAdd = isPeriod &amp;&amp; doc.weekCondition[minDay];
                            }
                            else if (3 === doc.interval)
                            {
                                var dayIndex = Number(model.momoent(key).format(&quot;D&quot;)) - 1;
                                isAdd = isPeriod &amp;&amp; doc.daysCondition[dayIndex].check;
                                
                                var targetDay = moment(key).format(&quot;YYYY-MM-DD&quot;);
                                var targetYearMonth = moment(key).format(&quot;YYYY-MM&quot;) + &quot;-&quot; + moment(key).daysInMonth();
                                console.log(targetDay + &quot;:&quot; +targetYearMonth);
                                if (targetDay == targetYearMonth)
                                {
                                    //最終日のチェックが優先される
                                    var lastIndex = doc.daysCondition.length -1;
                                    isAdd = isPeriod &amp;&amp; doc.daysCondition[lastIndex].check; 
                                }
                            }
                            target.scenario_type_detail = 3;
                        }
                        if (isAdd)
                        {
                            calendar[key].push({
                                scenario_id: target.scenario_id, 
                                scenario_name: target.scenario_name,
                                scenario_type_value: target.scenario_type_value,
                                scenario_type_detail: target.scenario_type_detail,
                                scenario_type_key: target.scenario_type_key
                            });
                        }
                    });
                }
                callback(null);
            }
        ], 
        function(err)
        {
            //月カレンダーの場合はさらに整形する
            if (isCalendar)
            {
                var calendarOfMonth = [];
                //angulerでリピートするときに、objectのプロパティの昇順になっちゃうから数値を含むキーを生成
                var weekList = {&quot;0sun&quot;: {}, &quot;1mon&quot;: {}, &quot;2tue&quot;: {}, &quot;3wed&quot;: {}, &quot;4thu&quot;: {}, &quot;5fri&quot;: {}, &quot;6sat&quot;: {}};
                var deforeCount = 1;
                Object.keys(calendar).forEach(function(key)
                {
                    //該当日が第N週かを求める
                    var day = model.momoent(key).format(&quot;D&quot;);
                    var weekdayNum = model.momoent(key).format(&quot;e&quot;);
                    var weekCount =Math.floor((day - weekdayNum + 12) / 7);
                    var weekday = model.momoent(key).format(&quot;dd&quot;);
                    var weekDayKey = weekdayNum + weekday;
                    
                    if (weekCount !== deforeCount)
                    {
                        calendarOfMonth.push(weekList);
                        weekList = {&quot;0sun&quot;: {}, &quot;1mon&quot;: {}, &quot;2tue&quot;: {}, &quot;3wed&quot;: {}, &quot;4thu&quot;: {}, &quot;5fri&quot;: {}, &quot;6sat&quot;: {}};
                    }
                    
                    weekList[weekDayKey].scenario = calendar[key];
                    weekList[weekDayKey].date = model.momoent(key).format(&quot;DD&quot;);
                    deforeCount = weekCount;
                });
                //最終週をセット
                calendarOfMonth.push(weekList);
                
                console.log(calendarOfMonth);
                
                var params = start.split(&quot;/&quot;);
                res.json({
                    data: calendarOfMonth, 
                    year: params[0],
                    month: params[1],
                });
            }
            else
            {
                res.json({data: calendar});
            }
        });
     });
};

function createDocsObject(docs)
{
    var docObject = {};
    var num = docs.length;
    for (var index = 0; index &lt; num; index++)
    {
        var doc = docs[index];
        docObject[doc.id] = doc;
    }
    
    return docObject;
}

/**
 * アプローチ対象のシナリオを無効にする
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.bulkInvalid = function(req, res)
{
    var commonColumns = model.getUpdCommonColumns();
    var sql = &#x27;UPDATE &#x27; + tableName + &#x27; SET status = @status, update_by = @update_by,  update_date = @update_date WHERE delete_flag = 0 AND approach = 1&#x27;; 
    var request = model.getRequest();
    request.input(&#x27;update_by&#x27;, model.db.Int, req.session.userId);
    request.input(&#x27;update_date&#x27;, model.db.NVarChar, commonColumns.update_date);
    request.input(&#x27;status&#x27;, model.db.Int, 0);

    model.execute(sql, request, function(err, data)
    {
        if (err.length &gt; 0)
        {
            console.log(&#x27;execute plan scenario bulk invalid faild&#x27;);
            console.log(err);
            return res.status(510).send(&#x27;無効化に失敗しました。&#x27;);
        }
        model.insertLog(req.session.userId, 8, Message.SCENARIO.I_003);
        res.status(200).send(&#x27;scenario status bulk invalid ok&#x27;);
    });
};

/**
 * アプローチ対象の無効なシナリオを有効にする
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.bulkEnable = function(req, res)
{
    var commonColumns = model.getUpdCommonColumns();
    var sql = &#x27;UPDATE &#x27; + tableName + &#x27; SET status = @status, update_by = @update_by,  update_date = @update_date WHERE delete_flag = 0 AND approach = 1&#x27;; 
    var request = model.getRequest();
    request.input(&#x27;update_by&#x27;, model.db.Int, req.session.userId);
    request.input(&#x27;update_date&#x27;, model.db.NVarChar, commonColumns.update_date);
    request.input(&#x27;status&#x27;, model.db.Int, 1);

    model.execute(sql, request, function(err, data)
    {
        if (err.length &gt; 0)
        {
            console.log(&#x27;execute plan scenario bulk enable faild&#x27;);
            console.log(err);
            return res.status(510).send(&#x27;有効化に失敗しました。&#x27;);
        }
        model.insertLog(req.session.userId, 8, Message.SCENARIO.I_002);
        res.status(200).send(&#x27;scenario status bulk enable ok&#x27;);
    });
};

/**
 * priorityとstatusを更新する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.savePriority = function(req, res)
{
    console.log(&#x27;scenario save priority execute&#x27;);
    console.log(req.body);
    var commonColumns = model.getUpdCommonColumns();

    model.async.forEach(req.body.data, function(item, callback)
    {
        //不要項目は削除
        delete item.scenario_name;
        delete item.scenario_type;
        delete item.valid_flag;
        delete item.scenario_type_key;
        
        var updateData = model.merge(item, commonColumns);

        var request = model.getRequest();
        request.input(&#x27;update_by&#x27;, model.db.Int, req.session.userId);
        request.input(&#x27;update_date&#x27;, model.db.NVarChar, updateData.update_date);
        
        request.input(&#x27;scenario_id&#x27;, model.db.Int, updateData.scenario_id);
        request.input(&#x27;priority&#x27;, model.db.Int, updateData.priority);
        request.input(&#x27;status&#x27;, model.db.Int, updateData.status);

        model.updateById(updateData, request, callback);
    }, 
    function (err) 
    {
        if (err.length &gt; 0)
        {
            console.log(&#x27;scenario priority update faild&#x27;);
            console.log(err);
            res.status(510).send(&#x27;scenario crate faild&#x27;);
        }
        
        model.insertLog(req.session.userId, 8, Message.SCENARIO.I_001);
        res.status(200).send(&#x27;scenario priority update ok&#x27;);
    });    
};

exports.getBySegmentId = function(segment_id, callback)
{
    var col = &quot;scenario_id, scenario_name, valid_flag&quot;;
    var where = &quot;delete_flag = 0 AND segment_id = @segment_id&quot;;
    var qObj = model.getQueryObject(col, tableName, where, &#x27;&#x27;, &#x27;&#x27;);
    qObj.request.input(&#x27;segment_id&#x27;, model.db.Int, segment_id);
    model.select(qObj, qObj.request, callback);
};

/**
 * シナリオを保存する
 * パラメータにPKが存在するか否かで登録するか更新するかを決定する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.save = function(req, res)
{
    console.log(&#x27;scenario save execute&#x27;);
    if (!req.body.hasOwnProperty(&#x27;scenario&#x27;)) res.status(510).send(&#x27;param is not found&#x27;);

    if (req.body.scenario.hasOwnProperty(&#x27;scenario_id&#x27;))
    {
        update(req, res);
    }
    else
    {
        model.async.parallel(
        {
            env: function(callback)
            {
                var env = require(&quot;./environment&quot;);
                env.get(callback);
            },
            count: function(callback)
            {
                var col = &quot;count(1) as count&quot;;
                var where = &quot;delete_flag = 0 and scenario_type = @scenario_type&quot;;
                var qObj = model.getQueryObject(col, tableName, where, &#x27;&#x27;, &#x27;&#x27;);
                qObj.request.input(&#x27;scenario_type&#x27;, model.db.SmallInt, req.body.scenario.scenario_type);
                model.select(qObj, qObj.request, callback);
            },
        },
        function complete(err, items)
        {
            if (0 &lt; err.length)
            {
                console.log(&#x27;scenario initialize data select faild&#x27;);
                console.log(err);
                return res.status(510).send(&#x27;システムエラーが発生しました。&#x27;);
            }
            var envInfo = items.env[0];
            var max = (1 == req.body.scenario.scenario_type) 
                ? envInfo.schedule_scenario_max : envInfo.trigger_scenario_max;
                
            if (max &lt;= items.count[0].count)
            {
                res.status(510).send(&#x27;これ以上登録できません。&lt;br&gt;不要なシナリオを削除してください。&#x27;);
            }
            else
            {
                create(req, res);
            }
        });
    }
};

/**
 * シナリオを登録する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
function create(req, res)
{
    scenariodoc.saveItemForWeb(true, req.body.doc, function(err, doc)
    {
        if (null !== err)
        {
            console.log(&#x27;scenario create doc faild&#x27;);
            console.log(err);
            console.log(req.body);
            return res.status(510).send(&#x27;シナリオドキュメントの作成に失敗しました&#x27;);
        }
        else
        {

            model.tranBegin(function(err, transaction)
            {
                model.async.waterfall(
                [
                    function(callback)
                    {
                        var commonColumns = model.getInsCommonColumns(req.session.userId);
                        var insertData = model.merge(req.body.scenario, commonColumns);
                        insertMine(transaction, insertData, function(err, scenarioId)
                        {
                            if (err.length &gt; 0)
                            {
                                console.log(&#x27;insert faild M_SCENARIO&#x27;);
                                console.log(err);
                                callback(err, {});
                                return;
                            }
                            callback(null, scenarioId);
                        });
                    },
                    function(scenarioId, callback)
                    {
                        insertChildren(transaction, req, scenarioId, doc, function(err, childTabelName)
                        {
                            if (err.length &gt; 0)
                            {
                                console.log(childTabelName + &#x27; insert faild&#x27;);
                                console.log(err);
                                callback(err, {});
                                return;
                            }
                            callback(null, scenarioId);
                        });
                    },
                    function(scenarioId, callback)
                    {
                        console.log(&quot;insert tag execute&quot;);
                        console.log(scenarioId);
                        insertTags(transaction, req.session.userId, req.body.tags, function(err, tagList)
                        {
                            console.log(err);
                            console.log(tagList);
                            if (null != err)
                            {
                                console.log(&quot;insert tags faild&quot;);
                                console.log(err);
                                callback(err);
                            }
                            else
                            {
                                callback(null, scenarioId, tagList);
                            }
                        });
                    },
                    function(scenarioId, tagList, callback)
                    {
                        console.log(&quot;insert scenario tag execute&quot;);
                        console.log(scenarioId);
                        console.log(tagList);
                        insertScnarioTag(transaction, req.session.userId, scenarioId, tagList, function(err, tagList)
                        {
                            callback(err);
                        });
                    }
                ],
                function(err)
                {
                    console.log(&quot;main last function&quot;);
                    console.log(err);
                    if (null != err)
                    {
                        console.log(&#x27;scenario insert faild&#x27;);
                        console.log(err);
                        
                        //documentを削除しなくちゃ
                        if (null !== doc)
                        {
                            scenariodoc.removeItemForWeb(doc.id, function(err, doc)
                            {
                                if (err)
                                {
                                    console.log(&#x27;scenario document remove faild&#x27;);
                                    console.log(err);
                                    console.log(doc);
                                }
                                transaction.rollback(function(err)
                                {
                                    if (err)
                                    {
                                        console.log(&#x27;scenario data rollback faild&#x27;);
                                        console.log(err);
                                        res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                                    }
                                    else
                                    {
                                        model.insertLog(req.session.userId, 8, Message.COMMON.E_001, req.body.scenario.scenario_name);
                                        res.status(510).send(&quot;シナリオの登録に失敗しました。&quot;);
                                    }
                                });
                            });
                        }
                    }
                    else
                    {
                        transaction.commit(function(err)
                        {
                            if (err)
                            {
                                console.log(&#x27;scenario data commit faild&#x27;);
                                console.log(err);
                                res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                            }
                            else
                            {
                                model.insertLog(req.session.userId, 8, Message.COMMON.I_001, req.body.scenario.scenario_name);
                                res.status(200).send(&#x27;insert ok&#x27;);
                            }
                        });
                    }
                });
            });
            
        }
    });
}

function insertMine(transaction, insertData, callback)
{
    var request = model.getRequest(transaction);

    request.input(&#x27;delete_flag&#x27;, model.db.SmallInt, insertData.delete_flag);
    request.input(&#x27;create_by&#x27;, model.db.Int, insertData.create_by);
    request.input(&#x27;create_date&#x27;, model.db.NVarChar, insertData.create_date);
    request.input(&#x27;update_by&#x27;, model.db.Int, insertData.update_by);
    request.input(&#x27;update_date&#x27;, model.db.NVarChar, insertData.update_date);
    
    request.input(&#x27;segment_id&#x27;, model.db.Int, insertData.segment_id);
    request.input(&#x27;if_layout_id&#x27;, model.db.Int, insertData.if_layout_id);
    request.input(&#x27;scenario_name&#x27;, model.db.NVarChar, insertData.scenario_name);
    request.input(&#x27;output_name&#x27;, model.db.NVarChar, insertData.output_name);
    request.input(&#x27;scenario_type&#x27;, model.db.SmallInt, insertData.scenario_type);
    request.input(&#x27;status&#x27;, model.db.SmallInt, insertData.status);
    request.input(&#x27;approach&#x27;, model.db.SmallInt, insertData.approach);
    request.input(&#x27;priority&#x27;, model.db.Int, 32767);

    model.insert(tableName, insertData, request, function(err, id)
    {
        callback(err, id);
    });
}

function insertChildren(transaction, req, id, doc, callback)
{
    var request = model.getRequest(transaction);
    var childTabelObject = &#x27;&#x27;;
    var childTabelName = &#x27;&#x27;;
    var specificInfo = {};
    
    if (1 === req.body.scenario.scenario_type)
    {
        var expiration_end_date = 
            (null === req.body.specificInfo.expiration_end_date || 0 === req.body.specificInfo.expiration_end_date.length) 
                ? null : req.body.specificInfo.expiration_end_date;
        specificInfo = 
        {
            repeat_flag: req.body.specificInfo.repeat_flag,
            expiration_start_date: req.body.specificInfo.expiration_start_date,
            expiration_end_date: expiration_end_date
        };
        
        childTabelObject = require(&quot;./schedulescenario&quot;);
        childTabelName = &#x27;M_SCHEDULE_SCENARIO&#x27;;
        request.input(&#x27;repeat_flag&#x27;, model.db.Int, specificInfo.repeat_flag);
        request.input(&#x27;expiration_start_date&#x27;, model.db.NVarChar, specificInfo.expiration_start_date);
        request.input(&#x27;expiration_end_date&#x27;, model.db.NVarChar, specificInfo.expiration_end_date);
    }
    else if (2 === req.body.scenario.scenario_type)
    {
        specificInfo = 
        {
            after_event_occurs_num: req.body.specificInfo.after_event_occurs_num,
            inoperative_num: req.body.specificInfo.inoperative_num
        };
        
        childTabelObject = require(&quot;./triggerscenario&quot;);
        childTabelName = &#x27;M_TRIGGER_SCENARIO&#x27;;
        request.input(&#x27;after_event_occurs_num&#x27;, model.db.Int, specificInfo.after_event_occurs_num);
        request.input(&#x27;inoperative_num&#x27;, model.db.Int, specificInfo.inoperative_num);
    }
    
    var commonColumns = model.getInsCommonColumns(req.session.userId);
    var insertData = model.merge(specificInfo, commonColumns);
    insertData.scenario_id = id;
    insertData.scenario_action_document_id = (null === doc) ? null : doc.id;

    request.input(&#x27;delete_flag&#x27;, model.db.SmallInt, insertData.delete_flag);
    request.input(&#x27;create_by&#x27;, model.db.Int, insertData.create_by);
    request.input(&#x27;create_date&#x27;, model.db.NVarChar, insertData.create_date);
    request.input(&#x27;update_by&#x27;, model.db.Int, insertData.update_by);
    request.input(&#x27;update_date&#x27;, model.db.NVarChar, insertData.update_date);
    request.input(&#x27;scenario_id&#x27;, model.db.Int, insertData.scenario_id);
    request.input(&#x27;scenario_action_document_id&#x27;, model.db.NVarChar, insertData.scenario_action_document_id);
    
    childTabelObject.saveForParent(insertData, request, function(err, data)
    {
        callback(err, childTabelName);
    });
}

/**
 * パラメータのtagsにidのプロパティがなければそれは新規作成となり
 * T_TAGに登録される。
 * ただし、同一名称のものが存在した場合は、登録しない。
 * 
 */
function insertTags(transaction, userid, tags, callback)
{
    console.log(&quot;insert tags&quot;);
    var tag = require(&quot;./tag&quot;);
    tag.save(transaction, userid, tags, function(err, tagList)
    {
        console.log(&quot;insert tags end&quot;);
        callback(err, tagList);
    });
}

/**
 * シナリオにタグを設定する
 * 
 */
function insertScnarioTag(transaction, userid, scenarioId, tags, callback)
{
    console.log(&quot;insert tags&quot;);
    var scenarioTag = require(&quot;./scenariottag&quot;);
    scenarioTag.save(transaction, userid, scenarioId, tags, function(err, tagList)
    {
        console.log(&quot;insert tags end&quot;);
        callback(err, tagList);
    });
}

/**
 * シナリオを更新する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
function update(req, res)
{
    console.log(&#x27;scenario update start&#x27;);
    var childTabelObject = &#x27;&#x27;;
    var childTabelName = &#x27;&#x27;;
    var isSchedule = (1 === req.body.scenario.scenario_type);
    if (isSchedule)
    {
        childTabelObject = require(&quot;./schedulescenario&quot;);
        childTabelName = &#x27;M_SCHEDULE_SCENARIO&#x27;;
    }
    else
    {
        childTabelObject = require(&quot;./triggerscenario&quot;);
        childTabelName = &#x27;M_TRIGGER_SCENARIO&#x27;;
    }
    
    var commonColumns = model.getUpdCommonColumns();
    
    model.tranBegin(function(err, transaction)
    {
        model.async.waterfall(
        [
            function(callback)
            {
                console.log(&#x27;get scenario by id&#x27;);
                console.log(req.body.scenario.scenario_id);
                childTabelObject.getByScenarioId(req.body.scenario.scenario_id, function(err, data)
                {
                    console.log(data);
                    if (err.length &gt; 0)
                    {
                        console.log(&#x27;trigger scenario is not found&#x27;);
                        console.log(err);
                        res.status(510).send(&#x27;scenario update faild&#x27;);
                        
                    }
                    callback(null, data);
                });
            },
            function(data, callback)
            {
                if (req.body.hasOwnProperty(&#x27;doc&#x27;))
                {
                    console.log(&#x27;update scenario doc&#x27;);
                    var doc = req.body.doc;
                    doc.id = data[0].scenario_action_document_id;
                    console.log(doc);
                    if (null === doc.id)
                    {
                        console.log(&#x27;no update scenario doc&#x27;);
                        callback(null);
                    }
                    else
                    {
                        scenariodoc.saveItemForWeb(false, doc, function(err, doc)
                        {
                            console.log(&#x27;scenario doc update&#x27;);
                            console.log(err);
                            console.log(doc);
                            callback(err);
                        });
                    }
                }
                else
                {
                    console.log(&#x27;no update scenario doc&#x27;);
                    callback(null);
                }
            },
            function(callback)
            {
                //scenarioマスタを更新
                delete req.body.scenario.delete_flag;
                delete req.body.scenario.create_by;
                delete req.body.scenario.create_date;
                delete req.body.scenario.priority;  //優先順位はここで更新したくないため削除
                //delete req.body.scenario.valid_flag;　
                console.log(commonColumns);
                var updateData = model.merge(commonColumns, req.body.scenario, true);
                //送信されてきたデータは信じない
                updateData.valid_flag = 1;
                console.log(updateData);
                
                var request = model.getRequest(transaction);
                request.input(&#x27;update_by&#x27;, model.db.Int, req.session.userId);
                request.input(&#x27;update_date&#x27;, model.db.NVarChar, updateData.update_date);
                
                request.input(&#x27;segment_id&#x27;, model.db.Int, updateData.segment_id);
                request.input(&#x27;if_layout_id&#x27;, model.db.Int, updateData.if_layout_id);
                request.input(&#x27;scenario_name&#x27;, model.db.NVarChar, updateData.scenario_name);
                request.input(&#x27;output_name&#x27;, model.db.NVarChar, updateData.output_name);
                request.input(&#x27;scenario_type&#x27;, model.db.SmallInt, updateData.scenario_type);
                request.input(&#x27;status&#x27;, model.db.SmallInt, updateData.status);
                request.input(&#x27;approach&#x27;, model.db.SmallInt, updateData.approach);
                request.input(&#x27;valid_flag&#x27;, model.db.SmallInt, updateData.valid_flag);
    
                console.log(&#x27;update scenario info&#x27;);
                model.updateById(updateData, request, function(err, data)
                {
                    var nextErr = (0 &lt; err.length) ? err.length: null;
                    callback(nextErr);
                });
            },
            function(callback)
            {
                //子テーブル更新
                var updateData = model.merge(commonColumns, req.body.specificInfo, true);
                updateData.scenario_id = req.body.scenario.scenario_id;
                
                var request = model.getRequest(transaction);
                request.input(&#x27;update_by&#x27;, model.db.Int, req.session.userId);
                console.log(&#x27;update &#x27; + childTabelName);
                childTabelObject.updateByScenarioId(updateData, request, function(err, data)
                {
                    console.log(err);
                    console.log(data);
                    var nextErr = (0 &lt; err.length) ? err.length: null;
                    callback(nextErr);
                });
            },
            function(callback)
            {
                insertTags(transaction, req.session.userId, req.body.tags, function(err, tagList)
                {
                    console.log(&quot;tag insert end next is sc tag&quot;);
                    console.log(err);
                    console.log(tagList);
                    if (null != err)
                    {
                        console.log(&quot;insert tags faild&quot;);
                        console.log(err);
                        callback(err);
                    }
                    else
                    {
                        //タグ更新
                        var scenarioTag = require(&quot;./scenariottag&quot;);
                        var param = {
                            userId: req.session.userId,
                            transaction: transaction, 
                            scenarioId: req.body.scenario.scenario_id, 
                            tagList: tagList};
                        scenarioTag.deleteInsert(param, callback);
                    }
                });
            }
        ], 
        function(err)
        {
            console.log(&#x27;execute last function&#x27;);
            if (null !== err &amp;&amp; 0 !== err.length)
            {
                console.log(err);
                
                transaction.rollback(function(err)
                {
                    if (err)
                    {
                        console.log(&#x27;scenario data rollback faild&#x27;);
                        console.log(err);
                        return res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                    }
                    else
                    {
                        model.insertLog(req.session.userId, 8, Message.COMMON.E_001, req.body.scenario.scenario_name);
                        return res.status(510).send(&quot;シナリオの更新に失敗しました。&quot;);
                    }
                });
            }
            else
            {
                console.log(&#x27;commit execute&#x27;);
                transaction.commit(function(err)
                {
                    console.log(err);
                    if (err)
                    {
                        console.log(&#x27;scenario data commit faild&#x27;);
                        console.log(err);
                        res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                    }
                    else
                    {
//                        model.insertLog(req.session.userId, 8, Message.COMMON.I_001, req.body.scenario.scenario_name);
                        res.status(200).send(&#x27;insert ok&#x27;);
                    }
                });
            }
        });
    });
}

/**
 * PKに合致したレコードのdelete_flagを1にする
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.remove = function(req, res)
{
    console.log(&#x27;scenario remove exexute&#x27;);
    
    if (!req.params.hasOwnProperty(&#x27;id&#x27;)) res.status(510).send(&#x27;scenario remove faild&#x27;);
    if (!req.params.hasOwnProperty(&#x27;type&#x27;)) res.status(510).send(&#x27;scenario remove faild&#x27;);

    var id = req.params.id;
    var type = req.params.type;
    var scenarioTypeObject = &#x27;&#x27;; 
    if (&#x27;trigger&#x27; === type)
    {
        scenarioTypeObject = require(&quot;./triggerscenario&quot;);
    }
    else
    {
        scenarioTypeObject = require(&quot;./schedulescenario&quot;);
    }
    
    scenarioTypeObject.getByScenarioId(id, function(err, typeData)
    {
        console.log(typeData);
        
        if (err.length &gt; 0)
        {
            console.log(&#x27;scenario remove faild&#x27;);
            console.log(id);
            console.log(err);
        }
        
        var exsitsData = true;
        if (0 === typeData.length)
        {
            console.log(&#x27;scenario type data not found&#x27;);
            console.log(id);
            exsitsData = false;
        }
        
        model.tranBegin(function(err, transaction)
        {
            //transactionはキューにしなきゃいけないからwaterfallで実効
            model.async.waterfall(
            [
                //トリガー情報削除
                function(callback)
                {
                    if (exsitsData)
                    {
                        var pk = 0;
                        if (&#x27;trigger&#x27; === type)
                        {
                            pk = typeData[0].trigger_scenario_id;
                        }
                        else if (&#x27;schedule&#x27; === type)
                        {
                            pk = typeData[0].schedule_scenario_id;
                        }
                        scenarioTypeObject.remove(pk, transaction, callback);
                    }
                    else
                    {
                        callback(null);
                    }
                },
                //シナリオ情報削除
                function(callback)
                {
                    model.removeByIdAndTran(id, transaction, function(err)
                    {
                        var errInfo = (0 &lt; err.length) ? err : null;
                        callback(errInfo);
                    });
                },
                function(callback)
                {
                    var scenarioTtag = require(&quot;./scenariottag&quot;);
                    scenarioTtag.removeByScenarioId(transaction, id, callback);
                },
            ], 
            function(err)
            {
                console.log(err);
                
                if (null != err)
                {
                    console.log(err);
                    transaction.rollback(function(err)
                    {
                        if (err)
                        {
                            console.log(&#x27;scenario data rollback faild&#x27;);
                            console.log(err);
                            return res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                        }
                        else
                        {
//                                        model.insertLog(req.session.userId, 8, Message.COMMON.E_001, typeData[0].);
                            return res.status(510).send(&quot;シナリオの削除に失敗しました。&quot;);
                        }
                    });
                }
                //シナリオdox削除
                if (exsitsData &amp;&amp; null !== typeData[0].scenario_action_document_id)
                {
                    console.log(&quot;doc delete&quot;);
                    var scenariodoc = require(&quot;./scenariodoc&quot;);
                    scenariodoc.removeItemForWeb(typeData[0].scenario_action_document_id, function(err)
                    {
                        console.log(&quot;doc delete complete&quot;);
                        if (err)
                        {
                            transaction.rollback(function(err)
                            {
                                if (err)
                                {
                                    console.log(&#x27;scenario data rollback faild&#x27;);
                                    console.log(err);
                                    res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                                }
                                else
                                {
//                                        model.insertLog(req.session.userId, 8, Message.COMMON.E_001, typeData[0].);
                                    return res.status(510).send(&quot;シナリオの削除に失敗しました。&quot;);
                                }
                            });
                        }
                        else
                        {
                            transaction.commit(function(err)
                            {
                                if (err)
                                {
                                    console.log(&#x27;scenario data commit faild 1&#x27;);
                                    console.log(err);
                                    res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                                }
                                else
                                {
    //                                model.insertLog(req.session.userId, 8, Message.COMMON.I_001, req.body.scenario.scenario_name);
                                    return res.status(200).send(&#x27;remove ok&#x27;);
                                }
                            });
                        }
                    });
                }
                else
                {
                    transaction.commit(function(err)
                    {
                        if (err)
                        {
                            console.log(&#x27;scenario data commit faild 2&#x27;);
                            console.log(err);
                            res.status(510).send(&quot;システムエラーが発生しました。&quot;);
                        }
                        else
                        {
//                                model.insertLog(req.session.userId, 8, Message.COMMON.I_001, req.body.scenario.scenario_name);
                            return res.status(200).send(&#x27;remove ok&#x27;);
                        }
                    });
                }
            });
        });
    });
};

/**
 * PKに合致したレコードを物理削除する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.delete = function(req, res)
{
    var id = req.params.id;
    model.deleteById(id, function(err, data)
    {
        if (err.length &gt; 0)
        {
            console.log(err);
            res.status(510).send(&#x27;object not found&#x27;);
        }
        res.status(200).send(&#x27;delete ok&#x27;);
    });
};

/**
 * シナリオコントロール画面に表示する初期値を取得する
 * リクエストにシナリオIDが存在する場合は該当情報も取得する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.initializeData = function(req, res)
{
    console.log(&#x27;scenario control initializeData&#x27;);
    model.async.parallel(
    {
        //セグメント情報
        segment: function(callback)
        {
            var table = &#x27;M_SEGMENT&#x27;;
            var col = &#x27;segment_id, segment_name&#x27;;
            var where = &#x27;delete_flag = 0&#x27;;
            var order = &#x27;segment_id&#x27;;
            var qObj = model.getQueryObject(col, table, where, &#x27;&#x27;, order);

            model.select(qObj, qObj.request,  function(err, data){callback(null, data)});
        },
        //IF情報
        ifLayout: function(callback)
        {
            var data = [{if_layout_id: 1, if_name: &#x27;デフォルトテンプレート&#x27;}];
            callback(null, data);
        },
        //アクション情報
        action: function(callback)
        {
            if (&#x27;trigger&#x27; === req.params.type)
            {
                var action = require(&#x27;../config/action.json&#x27;);
                var list = [];
                Object.keys(action).forEach(function(key)
                {
                    var target = action[key];
                    list.push({logicalname: target.logicalname, physicalname: target.physicalname, description: target.description});
                });
                
                callback(null, list);
            }
            else if (&#x27;schedule&#x27; === req.params.type)
            {
                callback(null, {});
            }
        },
        //該当情報
        target: function(callback)
        {
            if (void 0 !== req.params.id)
            {
                model.getById(req.params.id, callback);
            }
            else
            {
                callback(null, {});
            }
        }
        //個別情報
    },
    function complete(err, items)
    {
        console.log(&quot;complete fuction start&quot;);
        //parallel実行した場合、5こめのfunctionが実行完了前に
        //completeしてしまう。これはたぶんライブラリのバグだと思うけど、
        //どうにもならないのでここでさらに実行させる
        model.async.parallel(
        {
            specificData: function(callback)
            {
                if (req.params.hasOwnProperty(&quot;id&quot;))
                {
                    var typeObject;
                    if (&#x27;trigger&#x27; === req.params.type)
                    {
                        typeObject = require(&quot;./triggerscenario&quot;);
                    }
                    else if (&#x27;schedule&#x27; === req.params.type)
                    {
                        typeObject = require(&quot;./schedulescenario&quot;);
                    }
                    typeObject.getByScenarioId(req.params.id, function(err, data)
                    {
                        console.log(data);
                        scenariodoc.getItemByIdForWeb(data[0].scenario_action_document_id, function(err, doc)
                        {
                            callback(null, {specific: data[0], doc: doc});
                        });
                    });
                }
                else
                {
                    callback(null, []);
                }
            },
            settinTags: function(callback)
            {
                var scenarioTag = require(&quot;./scenariottag&quot;);
                if (req.params.hasOwnProperty(&quot;id&quot;))
                {
                    scenarioTag.getByScenarioId(req.params.id, function(err, data){callback(null, data)});
                }
                else
                {
                    callback(null, []);
                }
                
            },
            tagList: function(callback)
            {
                var tag = require(&quot;./tag&quot;);
                tag.getAll(function(err, data){callback(null, data)});
                
            }
        },
        function complete(err, items2)
        {
            console.log(err);
            res.json(
                {
                    segment: items.segment,
                    ifLayout: items.ifLayout,
                    specific: items.action, 
                    target: items.target[0], 
                    specificInfo: items2.specificData,
                    settinTags: items2.settinTags,
                    tagList: items2.tagList,
                });
        });
    });
};

/**
 * 同一名称が存在するかをチェックする
 * リクエスト値にシナリオIDが存在する場合は該当レコードの名称を除外してチェックする
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.isSameName = function(req, res)
{
    var scenarioId = req.body.id;
    if (void 0 === scenarioId)
    {
        model.isSameItem(&#x27;scenario_name&#x27;, req.body.scenario_name, model.db.NVarChar, function(err, result)
        {
            if (err.length &gt; 0)
            {
                console.log(err);
                res.status(510).send(&#x27;query execute faild&#x27;);
            }
            res.json({result: result[0]});
        });
    }
    else
    {
        var conditions = [
            {columns: pk, type: model.db.Int, value: scenarioId, symbol: &#x27;!=&#x27;},
            {columns: &#x27;scenario_name&#x27;, type: model.db.NVarChar, value: req.body.scenario_name, symbol: &#x27;=&#x27;},
        ];
        model.isSameItemByMultipleCondition(conditions , function(err, result)
        {
            if (err.length &gt; 0)
            {
                console.log(err);
                res.status(510).send(&#x27;query execute faild&#x27;);
            }
            res.json({result: result[0]});
        });
    }
};

/**
 * action.jsonからパラメータのnameと合致する情報を取得する
 * 
 * @param {Object} req 画面からのリクエスト
 * @param {Object} res 画面へのレスポンス
 */
exports.getActionByName = function(req, res)
{
    var physicalname = req.params.name;
    if (void 0 === physicalname) res.status(510).send(&#x27;params not found&#x27;);

    var action = require(&#x27;../config/action.json&#x27;);
    if (action.hasOwnProperty(physicalname))
    {
        res.json({data: action[physicalname]});
    }
    else
    {
        res.status(510).send(&#x27;action is not found&#x27;);
    }
};
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
